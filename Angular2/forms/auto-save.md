# Top Level Overview of Auto Save in myGPS

## Requirement

Save edited financial data when user stops making modification.

## Technical Breakdown to Achieve Requirement

1.  Track each financial entry as one piece of data
2.  Each entry (referred to as _TableRowEntry_) has ui required properties to properly support auto save functionality
    - **uiGuid**: a Global Unique ID used by UI for tracking row entries when saving occurs
    - **isValid**: a boolean state to track validity of rows
    - **isPristine**: a boolean state to track if a row's data has been saved to the Data Base
    - **isSavingInProgress**: a boolean state to track if a row's data is currently being saved (set to true between request and response for a particular row)
    - there are other conditions specific to certain financial sections which filter rows from auto save (ie. isReadOnly)

## How we determine if a Financial Row Entry requires saving

The conditions to determine if a financial row entry [*TableRowEntry*] requires saving.

| Condition                      | Explanation                                                     |
| ------------------------------ | --------------------------------------------------------------- |
| `isValid === true`             | TableRowEntry passes validation specific to the entry type      |
| `isPristine === false`         | TableRowEntry data has been modified since it's last save       |
| `isSavingInProgress === false` | TableRowEntry does **not** have any outstanding saving requests |

A memoize selector is used to aggregate all rows that fit the above conditions (with some extra properties depending on section). Subscribing to this selector allows us to dispatch an action which triggers the save request for this data.

## Life Cycle of a TableRowEntry

1.  Pre-load Request Sequence
2.  Post Pre-load Data Validation
3.  Data is ready to be interacted with
4.  User makes modifications
5.  Auto Save is triggered for TableRowEntries that meet conditions
6.  Auto Save Request Sequence
7.  Return to Step 3.

### 1. Pre-load Request Sequence

On application a pre-load request sequence begins which aggregates all household client data, financial client data and financial default settings.

```ts
// This is a sample TableRowEntry object created by Step 1.
{
  ...TableRowEntry,
  uiGuid: '39a0689e-a44b-ab92-94fb-194408f30e0e' // Generated by createGuid()
}
```

### 2. Post Pre-load Data Validation

When pre-load response is received financial client data is validated against validation rules to update validity for each TableRowEntry. This allows us to provide error indication on the side menu when the application loads.

```ts
// This is a sample TableRowEntry object created by Step 2.
{
  ...TableRowEntry,
  // Update isValid using a specific FormService.createValidatedTableRowCollection()
  isValid: true/false
}
```

### 3. Data is ready to be interacted with

This is when the application is waiting for the user to make modifications. No auto-save requests are triggered until step 5.

### 4. User makes modifications

When a user makes modifications to a TableRowEntry the update is pushed to Redux. This updates the state of a TableRowEntry to be `isPristine === false` along with its validity.

```ts
// This is a sample TableRowEntry object created by Step 4.
{
  // Update TableRowEntry using a specific FormService.createTableRow()
  ...updateTableRowEntry,
  isValid: true/false, // Depending on validity
  isPristine: false
}
```

### 5. Auto Save is triggered for TableRowEntries that meet conditions

After a user has made modification and no changes have been made for a set amount of time we trigger an auto save action.

```ts
// Example of a selector filtering TableRowEntries that require saving
const tableRowEntriesRequiringSaveMemoizedSelector = createSelector(
  tableRowEntriesMemoizedSelector,
  tableRowEntries => {
    // Filtered entries that meet auto save requirements
    const tableRowEntriesRequiringSave = tableRowEntries.filter(
      item => !item.isPristine && item.isValid && !item.isSavingInProgress,
    );

    // If there are entries return them
    if (tableRowEntriesRequiringSave.length > 0) {
      return tableRowEntriesRequiringSave;
    }
  },
);

// Amount of milliseconds after which we trigger auto save
const autoSaveDebounce = 500;

// In the specific data service add a subscription to the above selector piped through the auto save debounce timer
class DataService {
  constructor(private store: Store<IStore>, private actions$: Actions) {
    store
      .select(tableRowEntriesRequiringSaveMemoizedSelector)
      .pipe(debounceTime(autoSaveDebounce))
      .subscribe(tableRowEntriesRequiringSave => {
        store.dispatch(
          // Use an action to trigger the save of these TableRowEntries
          {
            type: 'SAVE_REQUEST_TABLE_ROW_ENTRIES',
            payload: tableRowEntriesRequiringSave,
          },
        );
      });
  }
}
```

We use `SAVE_REQUEST_TABLE_ROW_ENTRIES` in the redux reducer to update `isPristine` and `isSavingInProgress` for the TableRowEntries which have been flagged for update.

- `isSavingInProgress` is important so that no other save requests happen while these are being saved.
- `isPristine` is important so that if the row is modified by the user during the saving progress we can track that modification has happen and send another request when saving is complete. Remember `isPristine` is set to false when a row is modified by the user in **Step 4**.

```ts
// This is a sample TableRowEntry object created by Step 5.
{
  ...TableRowEntry,
  isPristine: true, // Since we began saving we want to reset isPristine to true in order to capture any updates that happen during the save request
  isSavingInProgress: true, // Save request is triggered
}
```

### 6. Auto Save Request Sequence

Once an action to save TableRowEntries has been trigger an API will be sent to save these in the database. Below is a simplified effect to basically explain how this works. The effect listens for an action with a type `SAVE_REQUEST_TABLE_ROW_ENTRIES` and calls `SaveTableRowEntriesApiRequest()` with the payload provided in **Step 5**. Once the request is complete this effect returns an action with a type `SAVE_RESPONSE_TABLE_ROW_ENTRIES` and provides both the response from the API and the request from the action that triggered the effect. This is important for the reducer in order to know which rows to update using the **request** and which ids to overwrite using the **response**.

```ts
// Data service as shown in step 5 but extended with the effect to handle save request.
class DataService {
  constructor(private store: Store<IStore>, private actions$: Actions) {
    // Same selector as in step 5 would be here to trigger the bellow effect
  }

  // An Effect which listens to the above dispatched save action
  @Effect()
  saveTableRowEntries$: Observable<Action> = this.actions$
    .ofType('SAVE_REQUEST_TABLE_ROW_ENTRIES')
    .pipe(
      map(action =>
        SaveTableRowEntriesApiRequest(action.payload) // Api request to save table row entries
          .map(apiResponse => ({
            type: 'SAVE_RESPONSE_TABLE_ROW_ENTRIES',
            payload: {
              response: apiResponse, // we need response to map database IDs to new TableRowEntries
              request: action.payload, // we need request in order to know which isSavingInProgress properties to change to false
            },
          })),
      ),
    );
}
```

When `SAVE_RESPONSE_TABLE_ROW_ENTRIES` action type is dispatched we use `payload.request` to update TableRowEntries as shown below. We change `isSavingInProgress` to false in order to trigger any future updates or if during the saving process more updates have been made we return to **Step 5**. Otherwise if no changes have been made during the saving process we return to **Step 3**.

```ts
// This is a sample TableRowEntry object created by Step 6.
{
  ...TableRowEntry,
  id: apiResponse.id, // we grab id from api and map it to the object that was being saved
  isSavingInProgress: false, // Save request is completed and we change this value to false
}
```
