# Auto Save Patterns for Data Tables

## Requirement

Save row from a form data table when user stops making modification. Each row is a unique entry in the database and it's validity must be checked before submitting to API. It should be possible to delete and add rows to the data table.

## Technical Breakdown to Achieve Requirement

1.  Track each form data table entry as one piece of data
2.  Each entry (referred to as DataTableRowEntry) has UI required properties to properly support auto save functionality
    - **uiID**: a user interface ID used by the web application to track table row entries when saving occurs
    - **isValid**: a boolean state to track validity of table row entries
    - **isSaved**: a boolean state to track if a row's data has been saved to the Data Base
    - **isSavingInProgress**: a boolean state to track if a row's data is currently being saved (set to true between request and response for a particular row)
3.  Track new data table row entries created by UI and match database IDs for these entries on their initial save request.

## How we determine if a Financial Row Entry requires saving

The conditions to determine if a financial row entry (DataTableRowEntry) requires saving.

| Condition                    | Explanation                                                         |
| ---------------------------- | ------------------------------------------------------------------- |
| isValid === true             | DataTableRowEntry passes validation specific to the entry type      |
| isSaved === false            | DataTableRowEntry data has been modified since it's last save       |
| isSavingInProgress === false | DataTableRowEntry does **not** have any outstanding saving requests |

A memoize selector is used to aggregate all rows that fit the above conditions (with some extra properties depending on section). Subscribing to this selector allows us to dispatch an action which triggers the save request for this data.

## Life Cycle of a DataTableRowEntry

1.  Load Data on Page Load
2.  Initial Validation of Data
3.  Data is ready to be interacted with
4.  User makes modifications
5.  Auto Save is triggered for TableRowEntries that meet conditions
6.  Auto Save Request Sequence
7.  Return to Step 3.

### 1. Load Data on Page Load

On application start a request is sent to fetch all data table row entries. When this data is received the UI should provide a uiID to each row so that we can universally track existing rows with an ID from the database and new rows created by the UI which haven't been saved yet.

```ts
// This is a sample DataTableRowEntry object created by Step 1.
{
  ...DataTableRowEntry,
  uiID: '39a0689e-a44b-ab92-94fb-194408f30e0e' // Generated by createGuid()
}
```

### 2. Initial Validation of Data

Once all data has been received in _Step 1_ we would like to cross validate all entries to check for their initial validity. This would provide some indicators to the user if anything data has issues when first loading the application.

```ts
// This is a sample DataTableRowEntry object created by Step 2.
{
  ...DataTableRowEntry,
  isValid: true/false
}
```

### 3. Data is ready to be interacted with

This is when the application is waiting for the user to make modifications. No auto-save requests are triggered until step 5.

### 4. User makes modifications

When a user makes modifications to a DataTableRowEntry the update is reflected in Redux. This updates the state of a DataTableRowEntry to be `isSaved === false` along with its validity.

```ts
// This is a sample DataTableRowEntry object created by Step 4.
{
  ...updateDataTableRowEntry,
  isValid: true/false, // Depending on validity
  isSaved: false
}
```

### 5. Auto Save is triggered for TableRowEntries that meet conditions

After a user has made modification and no changes have been made for a set amount of time we trigger an auto save action.

```ts
// Example of a selector filtering dataTableRowEntries that require saving
const dataTableRowEntriesRequiringSaveMemoizedSelector = createSelector(
  dataTableRowEntriesMemoizedSelector, // another memoize selector with grabs all data rows
  dataTableRowEntries => {
    // Filtered entries that meet auto save requirements
    const dataTableRowEntriesRequiringSave = dataTableRowEntries.filter(
      item => !item.isSaved && item.isValid && !item.isSavingInProgress,
    );

    // If there are entries return them
    if (dataTableRowEntriesRequiringSave.length > 0) {
      return dataTableRowEntriesRequiringSave;
    }
  },
);

// Amount of milliseconds after which we trigger auto save
const autoSaveDebounce = 500;

// In the specific data service add a subscription to the above selector piped through the auto save debounce timer
class DataService {
  constructor(private store: Store<IStore>, private actions$: Actions) {
    store
      .select(tableRowEntriesRequiringSaveMemoizedSelector)
      .pipe(debounceTime(autoSaveDebounce))
      .subscribe(tableRowEntriesRequiringSave => {
        store.dispatch(
          // Use an action to trigger the save of these TableRowEntries
          {
            type: 'SAVE_REQUEST_TABLE_ROW_ENTRIES',
            payload: tableRowEntriesRequiringSave,
          },
        );
      });
  }
}
```

We use `SAVE_REQUEST_TABLE_ROW_ENTRIES` in the redux reducer to update `isSaved` and `isSavingInProgress` for the TableRowEntries which have been flagged for update.

- `isSavingInProgress` is important so that no other save requests happen for these particular table row entries while they are being saved.
- `isSaved` is important so that if a row is modified by the user during the saving progress we can track that modification has happen and send another request when the current save request is complete. Looking back you can see that `isSaved` is set to false when a row is modified by the user in **Step 4**.

```ts
// This is a sample DataTableRowEntry object created by Step 5.
{
  ...DataTableRowEntry,
  isSaved: true, // Since we began saving we want to reset isSaved to true in order to capture any updates that happen during the save request
  isSavingInProgress: true, // Save request is triggered
}
```

### 6. Auto Save Request Sequence

Once an action to save DataTableRowEntries has been triggered an API will be sent to save these in the database. Below is a simplified effect to explain how this works. The effect listens for an action with a type `SAVE_REQUEST_TABLE_ROW_ENTRIES` and calls `SaveTableRowEntriesApiRequest()` with the payload provided in **Step 5**. Once the request is complete this effect returns an action with a type `SAVE_RESPONSE_TABLE_ROW_ENTRIES` and provides both the response from the API and the request from the action that triggered the effect. This is important for the reducer in order to know which rows to update using the **request** and which ids to overwrite using the **response**.

```ts
// Data service as shown in step 5 but extended with the effect to handle save request.
class DataService {
  constructor(private store: Store<IStore>, private actions$: Actions) {
    // Same selector as in step 5 would be here to trigger the bellow effect
  }

  // An Effect which listens to the above dispatched save action
  @Effect()
  saveTableRowEntries$: Observable<Action> = this.actions$
    .ofType('SAVE_REQUEST_TABLE_ROW_ENTRIES')
    .pipe(
      map(action =>
        SaveTableRowEntriesApiRequest(action.payload) // Api request to save table row entries
          .map(apiResponse => ({
            type: 'SAVE_RESPONSE_TABLE_ROW_ENTRIES',
            payload: {
              response: apiResponse, // we need response to map database IDs to new TableRowEntries
              request: action.payload, // we need request in order to know which isSavingInProgress properties to change to false
            },
          })),
      ),
    );
}
```

When `SAVE_RESPONSE_TABLE_ROW_ENTRIES` action type is dispatched we use `payload.request` to update TableRowEntries as shown below. We change `isSavingInProgress` to false in order to trigger any future updates or if during the saving process more updates have been made we return to **Step 5**. Otherwise if no changes have been made during the saving process we return to **Step 3**.

```ts
// This is a sample DataTableRowEntry object created by Step 6.
const request = action.payload.request;
const response = action.payload.response;

DataTableRowEntries.map(
  DataTableRowEntry =>
    // Does this DataTableRowEntry exist in the request payload?
    request.find(
      savedTableRow => savedTableRow.uiID === DataTableRowEntry.uiID,
    ) !== undefined
      ? // if yes
        {
          ...DataTableRowEntry,
          id: response.find(
            responseTableRow =>
              responseTableRow.uiID === DataTableRowEntry.uiID,
          ).id, // we grab id from api and map it to the object that was being saved
          isSavingInProgress: false, // Save request is completed and we change this value to false
        }
      : // if no
        DataTableRowEntry,
);
```
